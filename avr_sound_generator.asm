; Sinus Generator
; 
; source text: tab width = 8

.DEVICE atmega328p

.dseg
abFSIdx: .Byte 12                       ; wave sample indices, each element points to a sample inside a different wave

.cseg

.org    0x0000
        rjmp    setup                   ; 'setup' als Start-Routine registrieren
        
.org    OVF0addr
        rjmp    isr_timer0              ; 't0over' als Timer0 Overflow-Routine registrieren

; these should have be known in the environment, gavrasm doesn't know them
.def YL         = r28
.def YH         = r29
.def ZL         = r30
.def ZH         = r31

; names for the registers to help humans to understand
.def nOne       = r1
.def nNULL      = r16
.def ZLsave     = r17
.def ZHsave     = r18
.def nSmpIx     = r19
.def nSmpVe     = r20
.def nBits      = r21   ; same as nBitsL for SW-DAC
.def nBitsL     = r21
.def nBitsH     = r22
.def mOut       = r23
.def rTemp      = r24
.def cNextWave  = r25   ; ! special register
.def mInputVal  = r26   ; ! special register 
.def mInputBit  = r27   ; ! special register X

;  A	    440.00 Hz
;  B	    466.16 Hz
;  H	    493.88 Hz
;  C	*   523.25 Hz
;CIS	*   554.37 Hz
;  D	*   587.33 Hz
;DIS	*   622.25 Hz
;  E	*   659.26 Hz
;  F	*   698.46 Hz
;FIS	*   739.99 Hz
;  G	*   783.99 Hz
;GIS	*   830.61 Hz
;  A	*   880.00 Hz
;  B	*   932.33 Hz
;  H	*   987.77 Hz
;  C	   1046.50 Hz
;CIS	   1108.73 Hz
;  D	   1174.66 Hz

; 2 bytes timing, has to be adjusted to 64*'C' = 33488 Hz
.equ    TPBH    = 0xfc                              ; High Byte des Timer Presets
.equ    TPBL    = 0x48			                    ; Low  Byte des Timer Presets

; ones per program start
    setup:
    
; setup interrupt generation

            cli                                     ; do not generate interrupts while setup phase

            ldi     rTemp,      LOW (RAMEND)        ; Stackpointer initialisieren
            out     SPL,        rTemp               ; -- " --
            ldi     rTemp,      HIGH(RAMEND)        ; -- " --
            out     SPH,        rTemp               ; -- " --

            ldi     rTemp,      0x00                ; set time1 to "no waveform generation & no compare match interrupt"
            sts     TCCR1A,     rTemp               ; -- " --
            ldi     rTemp,      0x01                ; set timer1 prescaler to 1
            sts     TCCR1B,     rTemp               ; -- " --

            ldi     rTemp,      0x02                ; set time1 to overflow interrupt timer
            sts     TIMSK1,     rTemp               ; -- " --

            ldi     rTemp,      TPBH                ; adjust timer for next interrupt
            sts     TCNT1H,     rTemp               ; -- " --
            ldi     rTemp,      TPBL                ; -- " --
            sts     TCNT1L,     rTemp               ; -- " --

; PORT definition

            ldi     r16,        0x00                ; r16 to input mode for pin 8 t0 13
            ldi     r17,        0xFF                ; pin 0 to 5 / 8 to 13
            ldi     r18,        0xFF                ; all pins

; define PORTB as input

            out     DDRC,       r16                 ; all pins to input 
            out     PORTC,      r17                 ; pin 8 to 13 to pullup

; define PORTD as output

            out     DDRD,       r18                 ; all pins to output

; from here on we will use register alias names as far as possible

; initialize a register with NULL for later use

            eor     nNULL,      nNULL               ; we need a NULL in a register :-(
            eor     nOne,       nOne                ; we need a 1 too :-((
            inc     nOne                            ; no ldi with r1 :-(((

; initialize all Frequency-Sample-Indices with "0"

            ldi     YL,         low (abFSIdx*2)     ; list of indeces of next sample in wave
            ldi     YH,         high(abFSIdx*2)     ;   -- " --

            ldi     r17,        0x02                ; the next address lies "2" further on
            ldi     r18,        0x0C                ; 12 Tunes
    FSIdx:
            st      Y,          nNULL               ; 0 => anPosFrequencies[n]
            add     YL,         r17                 ; next address
            adc     YH,         nNULL               ;   -- " --
            dec     r18                             ; one done
            brne    FSIdx                           ; more to do?

            sei                                     ; setup is ended, allow generation of interrupts

    wait:
            rjmp wait                               ; wait for ever, interrupt is called as configured

; START OF THE INTERRUPT SERVICE ROUTINE

    isr_timer0:
    read_start:
            ldi     rTemp,      TPBH                ; adjust timer for next interrupt
            sts     TCNT1H,     rTemp               ; -- " --
            ldi     rTemp,      TPBL                ; -- " --
            sts     TCNT1L,     rTemp               ; -- " --


; list of sample indices into the wave to Y

            ldi     YL,         low (abFSIdx*2)     ; load Y to point to the start of frequence sample index array "C"
            ldi     YH,         high(abFSIdx*2)     ;   -- " --

; start pointer of the wave to Z and to copy registers

            ldi     ZL,         low (abWaveSet*2)   ; load Z to point to start of 2D wave matrix
            ldi     ZH,         high(abWaveSet*2)   ;   -- " --
            mov     ZLsave,     ZL                  ; sometimes we need the startpoint again later on
            mov     ZHsave,     ZH                  ;   -- " --

; reset output value (sample sum)

            eor     nBitsL,     nBitsL
            eor     nBitsH,     nBitsH

; start on input pin 0

            ldi     mInputBit,  0x01                ; starting the big loop
            ror     mInputBit                       ; set carry flag

; here all things are starting

; read in the situation

    read:
            rol     mInputBit                       ; the first bit loures in the carry flag
            sbrc    mInputBit,  0x06                ; the last bit we are allowed to start a run
            rjmp    dac

            in      mInputVal,  PINC                ; check whats ON
            and     mInputVal,  mInputBit
            breq    run                             ; a bit is 0, so we have to act

            add     YL,         nOne                ; the next element of the frequence vector
            adc     YH,         nNULL

            ldi     rTemp,      64
            add     ZLsave,     rTemp               ; the next wave
            adc     ZHsave,     nNULL
            add     ZLsave,     rTemp
            adc     ZHsave,     nNULL

            rjmp    read                            ; check the next pin/key

; here we produce a sound wave

    run:
            mov     ZL,         ZLsave              ; sometimes we need the start again later on
            mov     ZH,         ZHsave              ;   -- " --

; add index of the next sample to wave pointer

            ld      nSmpIx,     Y                   ; anPosFrequencies[0] => register nSmpIx
            add     ZL,         nSmpIx              ; add nSmpIx to wave pointer &abWaveSet[abFSIdx[n]]
            adc     ZH,         nNULL
            add     ZL,         nSmpIx              ;   -- " --
            adc     ZH,         nNULL

; get and check the next sample

    strt1:
            lpm                                     ; load [Z] to r0
            tst     r0                              ; set the flag regarding to the content
            brne    next1                           ; if not 0, we are done with reading

; end of wave, restart the wave

            mov     ZL,         ZLsave              ; reset Z to start of current wave to restart the wave
            mov     ZH,         ZHsave              ;   -- " --
            mov     nSmpIx,     nNULL               ; the sample pointer becomes 0 too
            rjmp    next2                           ; decrement to prevent increment to modify shift ones to many

            eor     r0,         r0                  ; the assumed sample value is 2 - the average end value
            inc     r0
            inc     r0

; output sample value

    next1:
            inc     nSmpIx                          ; next time the next sample
    next2:
            st      Y,          nSmpIx              ; write back to abFSIdx

 ;           lsr     r0
            add     nBitsL,     r0                  ; accumulate all samples of all runs 
            adc     nBitsH,     nNULL
            sbrs    mInputBit,  0x05                ; the last bit we are allowed to
            rjmp    read


; D to A converter

; divide by 32 to scale down into a 0 to 6 range (38 would be better)

    dac:                                            ; Digital to Analog converter
    
            lsr     nBitsL                          ; divide two bytes by two
            sbrc    nBitsH,     0                   ;   -- " --
            ori     nBitsL,     0x80                ;   -- " --
            lsr     nBitsH                          ;   -- " --

            lsr     nBitsL
            sbrc    nBitsH,     0
            ori     nBitsL,     0x80
            lsr     nBitsH

            lsr     nBitsL
            sbrc    nBitsH,     0
            ori     nBitsL,     0x80
            lsr     nBitsH

            lsr     nBitsL
            sbrc    nBitsH,     0
            ori     nBitsL,     0x80
            lsr     nBitsH

            lsr     nBitsL
            sbrc    nBitsH,     0
            ori     nBitsL,     0x80
            lsr     nBitsH

            lsr     nBits                           ; divide one byte by two
;            lsr     nBits

            eor     mOut,       mOut                ; initialize output byte

; cummulate bits

            inc     nBits                           ; prepair nBits
    for:    
            dec     nBits                           ; loop for bits to set
            breq    end                             ; break if no bits to set anymore

            lsl     mOut                            ; shift existing bits
            ori     mOut,       0x04                ; insert bit 2
            rjmp    for                             ; loop to-for

    end:                                            ; output result
            out     PORTD,      mOut                ; 

            reti


abWaveSet:
;=======================================================================================================================================================================
C:   .db 0x01,0x01,0x03,0x06,0x0A,0x0F,0x16,0x1D,0x26,0x2F,0x39,0x44,0x4F,0x5B,0x67,0x73,0x7F,0x8C,0x98,0xA4,0xB0,0xBB,0xC6,0xD0,0xD9,0xE2,0xE9,0xF0,0xF5,0xF9,0xFC,0xFE
     .db 0xFF,0xFE,0xFC,0xF9,0xF5,0xF0,0xE9,0xE2,0xD9,0xD0,0xC6,0xBB,0xB0,0xA4,0x98,0x8C,0x80,0x73,0x67,0x5B,0x4F,0x44,0x39,0x2F,0x26,0x1D,0x16,0x0F,0x0A,0x06,0x03,0x00
CIS: .db 0x01,0x01,0x03,0x07,0x0B,0x11,0x18,0x21,0x2A,0x34,0x3F,0x4B,0x57,0x64,0x71,0x7E,0x8B,0x98,0xA5,0xB2,0xBD,0xC9,0xD3,0xDC,0xE5,0xEC,0xF3,0xF8,0xFB,0xFE,0xFE,0xFE
     .db 0xFC,0xF9,0xF5,0xEF,0xE8,0xE0,0xD7,0xCD,0xC2,0xB6,0xAA,0x9E,0x91,0x84,0x76,0x69,0x5C,0x50,0x44,0x39,0x2E,0x24,0x1C,0x14,0x0E,0x08,0x03,0x00,0x00,0x00,0x00,0x00
D:   .db 0x01,0x01,0x04,0x07,0x0D,0x13,0x1B,0x24,0x2F,0x3A,0x46,0x53,0x60,0x6E,0x7C,0x8A,0x98,0xA5,0xB2,0xBF,0xCB,0xD5,0xDF,0xE8,0xEF,0xF5,0xFA,0xFD,0xFE,0xFE,0xFD,0xFA
     .db 0xF5,0xEF,0xE8,0xDF,0xD6,0xCB,0xBF,0xB3,0xA6,0x98,0x8A,0x7C,0x6E,0x61,0x53,0x46,0x3A,0x2F,0x25,0x1B,0x13,0x0D,0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
DIS: .db 0x01,0x01,0x04,0x08,0x0E,0x16,0x1E,0x29,0x34,0x40,0x4E,0x5C,0x6A,0x79,0x88,0x96,0xA5,0xB3,0xC0,0xCC,0xD7,0xE1,0xEA,0xF2,0xF7,0xFB,0xFE,0xFE,0xFD,0xFB,0xF6,0xF0
     .db 0xE9,0xE0,0xD5,0xCA,0xBD,0xB0,0xA2,0x94,0x85,0x76,0x67,0x59,0x4B,0x3E,0x32,0x27,0x1D,0x14,0x0D,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
E:   .db 0x01,0x01,0x04,0x09,0x10,0x18,0x22,0x2D,0x3A,0x47,0x56,0x65,0x75,0x84,0x94,0xA3,0xB2,0xC0,0xCD,0xD9,0xE3,0xEC,0xF3,0xF9,0xFD,0xFE,0xFE,0xFC,0xF8,0xF2,0xEA,0xE1
     .db 0xD6,0xCA,0xBD,0xAF,0xA0,0x91,0x81,0x71,0x62,0x53,0x45,0x37,0x2B,0x20,0x16,0x0E,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
F:   .db 0x01,0x02,0x05,0x0A,0x12,0x1B,0x26,0x32,0x40,0x4F,0x5F,0x6F,0x80,0x90,0xA1,0xB0,0xBF,0xCD,0xDA,0xE4,0xEE,0xF5,0xFA,0xFD,0xFE,0xFD,0xFA,0xF5,0xED,0xE4,0xD9,0xCC
     .db 0xBE,0xB0,0xA0,0x8F,0x7F,0x6E,0x5E,0x4E,0x3F,0x32,0x25,0x1A,0x11,0x0A,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
FIS: .db 0x01,0x02,0x05,0x0B,0x14,0x1E,0x2A,0x38,0x47,0x57,0x68,0x7A,0x8C,0x9D,0xAE,0xBE,0xCC,0xDA,0xE5,0xEF,0xF6,0xFB,0xFE,0xFE,0xFC,0xF8,0xF1,0xE8,0xDD,0xD0,0xC2,0xB2
     .db 0xA1,0x90,0x7E,0x6D,0x5C,0x4B,0x3C,0x2D,0x21,0x16,0x0D,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
G:   .db 0x01,0x02,0x06,0x0D,0x16,0x21,0x2F,0x3E,0x4F,0x60,0x73,0x85,0x98,0xAA,0xBB,0xCB,0xD9,0xE5,0xEF,0xF7,0xFC,0xFE,0xFE,0xFB,0xF5,0xED,0xE2,0xD5,0xC7,0xB6,0xA5,0x93
     .db 0x80,0x6E,0x5B,0x4A,0x3A,0x2B,0x1E,0x13,0x0A,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
GIS: .db 0x01,0x02,0x07,0x0E,0x18,0x25,0x34,0x45,0x57,0x6A,0x7E,0x92,0xA5,0xB7,0xC8,0xD8,0xE5,0xEF,0xF7,0xFC,0xFE,0xFD,0xF9,0xF2,0xE8,0xDC,0xCD,0xBD,0xAB,0x98,0x84,0x70
     .db 0x5D,0x4B,0x39,0x2A,0x1C,0x11,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
A:   .db 0x01,0x02,0x07,0x10,0x1B,0x29,0x3A,0x4C,0x60,0x75,0x8A,0x9E,0xB2,0xC5,0xD5,0xE3,0xEF,0xF7,0xFD,0xFE,0xFD,0xF8,0xF0,0xE4,0xD6,0xC6,0xB3,0x9F,0x8B,0x76,0x61,0x4D
     .db 0x3B,0x2A,0x1C,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
B:   .db 0x01,0x02,0x08,0x12,0x1E,0x2E,0x40,0x54,0x6A,0x80,0x96,0xAB,0xC0,0xD2,0xE1,0xEE,0xF7,0xFD,0xFE,0xFC,0xF6,0xED,0xE0,0xD0,0xBE,0xAA,0x94,0x7E,0x68,0x53,0x3F,0x2D
     .db 0x1D,0x11,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
H:   .db 0x01,0x03,0x09,0x14,0x22,0x33,0x47,0x5D,0x74,0x8C,0xA3,0xB9,0xCD,0xDE,0xEC,0xF6,0xFD,0xFE,0xFC,0xF5,0xEB,0xDC,0xCB,0xB7,0xA1,0x8A,0x72,0x5B,0x45,0x31,0x20,0x12
     .db 0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
